<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>自修室去水印V1.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        background-color: #f8fafc;
        overscroll-behavior: none;
      }
      /* Custom scrollbar for cleaner look */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #f1f5f9; 
      }
      ::-webkit-scrollbar-thumb {
        background: #cbd5e1; 
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #94a3b8; 
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.30.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>
    <script>
      // Polyfill process.env for API Key if not present
      if (typeof process === 'undefined') {
        window.process = { env: { API_KEY: '' } };
      }
    </script>
    <script type="text/babel" data-type="module" data-presets="react,typescript">
      import React, { useState, useRef, useEffect, useCallback } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenAI } from "@google/genai";

      // Ensure process is available in module scope
      const process = window.process;

      // --- Types ---
      interface Point {
        x: number;
        y: number;
      }

      interface DrawPath {
        points: Point[];
        size: number;
      }

      enum EditorMode {
        DRAW = 'DRAW',
        PAN = 'PAN',
      }

      // --- Service ---
      // Initialize Gemini Client
      // Use process.env.API_KEY safely.
      const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

      /**
       * Sends the original image and the mask to Gemini to perform inpainting/removal.
       */
      const removeWatermark = async (
        originalImageBase64: string,
        maskImageBase64: string
      ): Promise<string> => {
        try {
          // Clean base64 strings if they contain headers
          const cleanOriginal = originalImageBase64.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, '');
          const cleanMask = maskImageBase64.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, '');

          const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: {
              parts: [
                {
                  text: "I am providing two images. The first image is the original photo. The second image is a black and white mask where white represents the area to be removed/edited. Please remove the object or watermark in the first image that corresponds to the white area in the second image. Fill the area seamlessly to match the surrounding background context. Return ONLY the resulting image."
                },
                {
                  inlineData: {
                    mimeType: 'image/png',
                    data: cleanOriginal,
                  },
                },
                {
                  inlineData: {
                    mimeType: 'image/png',
                    data: cleanMask,
                  },
                },
              ],
            },
          });

          // Iterate through parts to find the image
          const candidates = response.candidates;
          if (candidates && candidates.length > 0) {
            const content = candidates[0].content;
            if (content.parts) {
              for (const part of content.parts) {
                if (part.inlineData && part.inlineData.data) {
                  return `data:image/png;base64,${part.inlineData.data}`;
                }
              }
            }
          }

          throw new Error("No image generated by the model.");

        } catch (error) {
          console.error("Error calling Gemini API:", error);
          throw error;
        }
      };

      // --- Icons ---
      const UploadIcon = () => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="17 8 12 3 7 8" />
          <line x1="12" y1="3" x2="12" y2="15" />
        </svg>
      );

      const BrushIcon = () => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="m9.06 11.9 8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.08" />
          <path d="M7.07 14.94c-1.66 0-3 1.35-3 3.02 0 1.33-2.5 1.52-2.5 2.24 0 .46.62.92 1.25.92 1.76 0 2.63-1.25 3.34-1.97.03-.03.1-.1.1-.1" />
        </svg>
      );

      const HandIcon = () => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0" />
          <path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2" />
          <path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8" />
          <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15" />
        </svg>
      );

      const UndoIcon = () => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M3 7v6h6" />
          <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" />
        </svg>
      );

      const RefreshIcon = () => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
          <path d="M21 3v5h-5" />
          <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
          <path d="M8 16H3v5" />
        </svg>
      );

      const DownloadIcon = () => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="7 10 12 15 17 10" />
          <line x1="12" y1="15" x2="12" y2="3" />
        </svg>
      );

      const CheckIcon = () => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <polyline points="20 6 9 17 4 12" />
        </svg>
      );

      const MagicIcon = () => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z" />
          <path d="M5 3v4" />
          <path d="M9 3v4" />
          <path d="M3 5h4" />
          <path d="M3 9h4" />
        </svg>
      );

      const LoaderIcon = () => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="animate-spin">
          <path d="M21 12a9 9 0 1 1-6.219-8.56" />
        </svg>
      );

      // --- Components ---
      
      interface ImageEditorProps {
        imageSrc: string;
        onGenerate: (maskBase64: string) => void;
        isProcessing: boolean;
      }

      const ImageEditor: React.FC<ImageEditorProps> = ({ imageSrc, onGenerate, isProcessing }) => {
        const containerRef = useRef<HTMLDivElement>(null);
        const canvasRef = useRef<HTMLCanvasElement>(null);
        const imageRef = useRef<HTMLImageElement | null>(null);

        // Editor State
        const [mode, setMode] = useState<EditorMode>(EditorMode.DRAW);
        const [brushSize, setBrushSize] = useState<number>(20);
        const [paths, setPaths] = useState<DrawPath[]>([]);
        
        // Viewport State
        const [scale, setScale] = useState<number>(1);
        const [offset, setOffset] = useState<Point>({ x: 0, y: 0 });
        const [isDragging, setIsDragging] = useState<boolean>(false);
        const [lastMousePos, setLastMousePos] = useState<Point>({ x: 0, y: 0 });
        
        // Drawing State
        const [isDrawing, setIsDrawing] = useState<boolean>(false);
        const [currentPath, setCurrentPath] = useState<Point[]>([]);

        // Initialize Image
        useEffect(() => {
          const img = new Image();
          img.src = imageSrc;
          img.onload = () => {
            imageRef.current = img;
            fitImageToContainer(img.width, img.height);
          };
        }, [imageSrc]);

        // Fit image to container initially
        const fitImageToContainer = (imgWidth: number, imgHeight: number) => {
          if (!containerRef.current) return;
          const { clientWidth, clientHeight } = containerRef.current;
          
          const scaleX = clientWidth / imgWidth;
          const scaleY = clientHeight / imgHeight;
          const initialScale = Math.min(scaleX, scaleY, 1) * 0.9; // 90% fit
          
          setScale(initialScale);
          setOffset({
            x: (clientWidth - imgWidth * initialScale) / 2,
            y: (clientHeight - imgHeight * initialScale) / 2
          });
          
          // Reset paths when image loads/changes
          setPaths([]);
        };

        // Draw loop
        useEffect(() => {
          const canvas = canvasRef.current;
          const img = imageRef.current;
          if (!canvas || !img) return;

          const ctx = canvas.getContext('2d');
          if (!ctx) return;

          // Set canvas dimensions to match image dimensions
          canvas.width = img.width;
          canvas.height = img.height;

          // Clear and draw image
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);

          // Draw Masks (Red translucent)
          ctx.save();
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          
          // Draw committed paths
          paths.forEach(path => {
            if (path.points.length < 1) return;
            ctx.beginPath();
            ctx.lineWidth = path.size;
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.moveTo(path.points[0].x, path.points[0].y);
            path.points.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
          });

          // Draw current path being drawn
          if (currentPath.length > 0) {
            ctx.beginPath();
            ctx.lineWidth = brushSize;
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            currentPath.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
          }
          
          ctx.restore();

        }, [imageSrc, paths, currentPath, brushSize]);

        // Helper: Get coordinates relative to image
        const getRelativeCoords = (e: React.MouseEvent | React.TouchEvent): Point | null => {
          if (!containerRef.current || !imageRef.current) return null;
          
          const rect = containerRef.current.getBoundingClientRect();
          const clientX = 'touches' in e ? e.touches[0].clientX : (e as React.MouseEvent).clientX;
          const clientY = 'touches' in e ? e.touches[0].clientY : (e as React.MouseEvent).clientY;

          // Mouse relative to container
          const containerX = clientX - rect.left;
          const containerY = clientY - rect.top;

          // Mouse relative to transformed image origin
          const imageX = (containerX - offset.x) / scale;
          const imageY = (containerY - offset.y) / scale;

          return { x: imageX, y: imageY };
        };

        // Event Handlers
        const handleMouseDown = (e: React.MouseEvent | React.TouchEvent) => {
          if (isProcessing) return;
          
          if (mode === EditorMode.PAN) {
            setIsDragging(true);
            const clientX = 'touches' in e ? e.touches[0].clientX : (e as React.MouseEvent).clientX;
            const clientY = 'touches' in e ? e.touches[0].clientY : (e as React.MouseEvent).clientY;
            setLastMousePos({ x: clientX, y: clientY });
          } else {
            const coords = getRelativeCoords(e);
            if (coords) {
              setIsDrawing(true);
              setCurrentPath([coords]);
            }
          }
        };

        const handleMouseMove = (e: React.MouseEvent | React.TouchEvent) => {
          if (isProcessing) return;

          if (mode === EditorMode.PAN && isDragging) {
            const clientX = 'touches' in e ? e.touches[0].clientX : (e as React.MouseEvent).clientX;
            const clientY = 'touches' in e ? e.touches[0].clientY : (e as React.MouseEvent).clientY;
            
            const dx = clientX - lastMousePos.x;
            const dy = clientY - lastMousePos.y;
            
            setOffset(prev => ({ x: prev.x + dx, y: prev.y + dy }));
            setLastMousePos({ x: clientX, y: clientY });
          } else if (mode === EditorMode.DRAW && isDrawing) {
            const coords = getRelativeCoords(e);
            if (coords) {
              setCurrentPath(prev => [...prev, coords]);
            }
          }
        };

        const handleMouseUp = () => {
          if (mode === EditorMode.PAN) {
            setIsDragging(false);
          } else if (mode === EditorMode.DRAW && isDrawing) {
            setIsDrawing(false);
            if (currentPath.length > 0) {
              setPaths(prev => [...prev, { points: currentPath, size: brushSize }]);
              setCurrentPath([]);
            }
          }
        };

        const handleWheel = (e: React.WheelEvent) => {
          const newScale = Math.max(0.1, Math.min(5, scale - e.deltaY * 0.001));
          setScale(newScale);
        };

        const generateMask = () => {
          if (!imageRef.current) return;
          
          const maskCanvas = document.createElement('canvas');
          maskCanvas.width = imageRef.current.width;
          maskCanvas.height = imageRef.current.height;
          const ctx = maskCanvas.getContext('2d');
          
          if (!ctx) return;
          
          // Fill black
          ctx.fillStyle = '#000000';
          ctx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
          
          // Draw white paths
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          paths.forEach(path => {
            if (path.points.length < 1) return;
            ctx.beginPath();
            ctx.lineWidth = path.size; // Same size as visual
            ctx.strokeStyle = '#FFFFFF';
            ctx.moveTo(path.points[0].x, path.points[0].y);
            path.points.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
          });

          const maskBase64 = maskCanvas.toDataURL('image/png');
          onGenerate(maskBase64);
        };

        const undo = () => {
          setPaths(prev => prev.slice(0, prev.length - 1));
        };

        const reset = () => {
          setPaths([]);
        };

        return (
          <div className="flex flex-col h-full w-full bg-slate-100 rounded-lg overflow-hidden shadow-sm border border-slate-200">
            
            {/* Canvas Area */}
            <div 
              ref={containerRef}
              className={`flex-1 overflow-hidden relative ${mode === EditorMode.PAN ? 'cursor-grab active:cursor-grabbing' : 'cursor-crosshair'}`}
              onMouseDown={handleMouseDown}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              onMouseLeave={handleMouseUp}
              onTouchStart={handleMouseDown}
              onTouchMove={handleMouseMove}
              onTouchEnd={handleMouseUp}
              onWheel={handleWheel}
            >
              <canvas
                ref={canvasRef}
                style={{
                  transform: `translate(${offset.x}px, ${offset.y}px) scale(${scale})`,
                  transformOrigin: '0 0',
                }}
                className="absolute top-0 left-0 touch-none"
              />
              
              {/* Helper text if needed */}
              {paths.length === 0 && !isDrawing && (
                <div className="absolute top-4 left-1/2 -translate-x-1/2 bg-black/50 text-white px-3 py-1 rounded-full text-xs pointer-events-none select-none backdrop-blur-sm">
                  使用画笔涂抹水印区域
                </div>
              )}
            </div>

            {/* Toolbar */}
            <div className="bg-white border-t border-slate-200 p-4 shrink-0">
              <div className="flex flex-col md:flex-row items-center justify-between gap-4">
                
                {/* Left: Tools */}
                <div className="flex items-center gap-2 bg-slate-100 p-1 rounded-lg">
                  <button
                    onClick={() => setMode(EditorMode.DRAW)}
                    className={`p-2 rounded-md transition-colors ${mode === EditorMode.DRAW ? 'bg-white shadow-sm text-blue-600' : 'text-slate-500 hover:text-slate-700'}`}
                    title="画笔工具"
                  >
                    <BrushIcon />
                  </button>
                  <button
                    onClick={() => setMode(EditorMode.PAN)}
                    className={`p-2 rounded-md transition-colors ${mode === EditorMode.PAN ? 'bg-white shadow-sm text-blue-600' : 'text-slate-500 hover:text-slate-700'}`}
                    title="抓手工具"
                  >
                    <HandIcon />
                  </button>
                </div>

                {/* Middle: Brush Settings */}
                {mode === EditorMode.DRAW && (
                  <div className="flex items-center gap-3 w-full max-w-xs px-2">
                    <span className="text-xs text-slate-500 font-medium whitespace-nowrap">笔刷大小</span>
                    <input 
                      type="range" 
                      min="5" 
                      max="100" 
                      value={brushSize} 
                      onChange={(e) => setBrushSize(Number(e.target.value))}
                      className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
                    />
                    <span className="text-xs text-slate-500 w-6 text-right">{brushSize}</span>
                  </div>
                )}

                {/* Right: Actions */}
                <div className="flex items-center gap-2">
                  <button
                    onClick={undo}
                    disabled={paths.length === 0 || isProcessing}
                    className="p-2 text-slate-600 hover:bg-slate-100 rounded-lg disabled:opacity-30 disabled:hover:bg-transparent"
                    title="撤销"
                  >
                    <UndoIcon />
                  </button>
                  <button
                    onClick={reset}
                    disabled={paths.length === 0 || isProcessing}
                    className="p-2 text-slate-600 hover:bg-slate-100 rounded-lg disabled:opacity-30 disabled:hover:bg-transparent"
                    title="重置"
                  >
                    <RefreshIcon />
                  </button>
                  
                  <div className="w-px h-6 bg-slate-300 mx-2"></div>

                  <button
                    onClick={generateMask}
                    disabled={paths.length === 0 || isProcessing}
                    className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium text-white transition-all
                      ${paths.length === 0 || isProcessing ? 'bg-blue-300 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700 shadow-md hover:shadow-lg active:translate-y-0.5'}
                    `}
                  >
                    <MagicIcon />
                    <span>开始去水印</span>
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      };

      interface CompareViewProps {
        originalImage: string;
        processedImage: string;
        onApply: () => void;
        onDownload: () => void;
        onCancel: () => void;
      }

      const CompareView: React.FC<CompareViewProps> = ({ originalImage, processedImage, onApply, onDownload, onCancel }) => {
        const [sliderPosition, setSliderPosition] = useState(50);
        const containerRef = useRef<HTMLDivElement>(null);
        const [isResizing, setIsResizing] = useState(false);

        const handleMouseDown = () => setIsResizing(true);
        const handleTouchStart = () => setIsResizing(true);

        const handleMove = (clientX: number) => {
          if (!containerRef.current) return;
          const rect = containerRef.current.getBoundingClientRect();
          const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
          const percent = (x / rect.width) * 100;
          setSliderPosition(percent);
        };

        const handleMouseMove = (e: React.MouseEvent) => {
          if (!isResizing) return;
          handleMove(e.clientX);
        };

        const handleTouchMove = (e: React.TouchEvent) => {
          if (!isResizing) return;
          handleMove(e.touches[0].clientX);
        };

        const handleStop = () => setIsResizing(false);

        useEffect(() => {
          document.addEventListener('mouseup', handleStop);
          document.addEventListener('touchend', handleStop);
          return () => {
            document.removeEventListener('mouseup', handleStop);
            document.removeEventListener('touchend', handleStop);
          };
        }, []);

        return (
          <div className="flex flex-col h-full w-full bg-slate-100 rounded-lg overflow-hidden shadow-sm border border-slate-200">
            
            {/* Compare Area */}
            <div 
              className="flex-1 relative bg-slate-800 flex items-center justify-center overflow-hidden select-none"
              onMouseMove={handleMouseMove}
              onTouchMove={handleTouchMove}
            >
              <div 
                ref={containerRef}
                className="relative max-w-full max-h-full aspect-auto"
                style={{ height: '100%', width: '100%' }}
              >
                {/* Background Image (After - Full) */}
                <img 
                  src={processedImage} 
                  alt="Processed" 
                  className="absolute top-0 left-0 w-full h-full object-contain pointer-events-none" 
                />

                {/* Foreground Image (Before - Clipped) */}
                <div 
                  className="absolute top-0 left-0 w-full h-full overflow-hidden pointer-events-none"
                  style={{ clipPath: `inset(0 ${100 - sliderPosition}% 0 0)` }}
                >
                  <img 
                    src={originalImage} 
                    alt="Original" 
                    className="absolute top-0 left-0 w-full h-full object-contain" 
                  />
                  {/* Labels */}
                  <div className="absolute top-4 left-4 bg-black/60 text-white px-2 py-1 text-xs rounded">原图</div>
                </div>
                
                <div className="absolute top-4 right-4 bg-blue-600/80 text-white px-2 py-1 text-xs rounded pointer-events-none">去水印后</div>

                {/* Slider Handle */}
                <div 
                  className="absolute top-0 bottom-0 w-1 bg-white cursor-ew-resize shadow-[0_0_10px_rgba(0,0,0,0.5)] z-10"
                  style={{ left: `${sliderPosition}%` }}
                  onMouseDown={handleMouseDown}
                  onTouchStart={handleTouchStart}
                >
                  <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-8 h-8 bg-white rounded-full shadow-md flex items-center justify-center text-slate-400">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                      <path d="m9 18-6-6 6-6"/>
                      <path d="m15 6 6 6-6 6"/>
                    </svg>
                  </div>
                </div>
              </div>
            </div>

            {/* Toolbar */}
            <div className="bg-white border-t border-slate-200 p-4 shrink-0">
              <div className="flex flex-col md:flex-row items-center justify-between gap-4">
                <div className="text-sm text-slate-500 font-medium">
                  拖拽滑块对比效果
                </div>
                
                <div className="flex items-center gap-3">
                  <button
                    onClick={onCancel}
                    className="flex items-center gap-2 px-4 py-2 rounded-lg text-slate-600 hover:bg-slate-100 transition-colors"
                  >
                    <RefreshIcon />
                    <span>重新涂抹</span>
                  </button>
                  <button
                    onClick={onDownload}
                    className="flex items-center gap-2 px-4 py-2 rounded-lg border border-slate-300 text-slate-700 hover:bg-slate-50 hover:border-slate-400 transition-colors"
                  >
                    <DownloadIcon />
                    <span>下载图片</span>
                  </button>
                  <button
                    onClick={onApply}
                    className="flex items-center gap-2 px-6 py-2 rounded-lg bg-green-600 text-white hover:bg-green-700 shadow-md hover:shadow-lg transition-all"
                  >
                    <CheckIcon />
                    <span>应用当前效果</span>
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      };

      const App: React.FC = () => {
        const [originalImage, setOriginalImage] = useState<string | null>(null);
        const [processedImage, setProcessedImage] = useState<string | null>(null);
        const [isProcessing, setIsProcessing] = useState(false);
        const [loadingText, setLoadingText] = useState("处理中...");

        const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
          const file = e.target.files?.[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
              if (event.target?.result) {
                setOriginalImage(event.target.result as string);
                setProcessedImage(null); // Reset prev state
              }
            };
            reader.readAsDataURL(file);
          }
        };

        const handleGenerate = async (maskBase64: string) => {
          if (!originalImage) return;

          setIsProcessing(true);
          setLoadingText("小刘正在卖力擦除中...");

          try {
            const result = await removeWatermark(originalImage, maskBase64);
            setProcessedImage(result);
          } catch (error) {
            console.error("Failed to process image:", error);
            const msg = (error as Error).message || "Unknown error";
            if (msg.includes('API Key')) {
               alert("API Key 配置无效，请检查 HTML 源码中的 process.env.API_KEY 设置。");
            } else {
               alert("处理失败，请稍后重试或检查网络设置。");
            }
          } finally {
            setIsProcessing(false);
          }
        };

        const handleApply = () => {
          if (processedImage) {
            setOriginalImage(processedImage);
            setProcessedImage(null);
          }
        };

        const handleDownload = () => {
          if (processedImage) {
            const link = document.createElement('a');
            link.href = processedImage;
            link.download = 'removed_watermark.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          }
        };

        const handleCancel = () => {
          setProcessedImage(null);
        };

        return (
          <div className="min-h-screen flex flex-col items-center p-4 md:p-8 max-w-7xl mx-auto">
            {/* Header */}
            <header className="w-full mb-6 flex items-center justify-between">
              <div>
                <h1 className="text-2xl font-bold text-slate-800 tracking-tight">自修室去水印 <span className="text-blue-600">V1.0</span></h1>
                <p className="text-slate-500 text-sm mt-1">简单涂抹，智能消除，还你清爽画面</p>
              </div>
              {originalImage && (
                <label className="cursor-pointer text-sm font-medium text-slate-600 hover:text-blue-600 transition-colors flex items-center gap-2 px-3 py-2 rounded-lg hover:bg-slate-100">
                  <UploadIcon />
                  <span>更换图片</span>
                  <input type="file" accept="image/*" onChange={handleFileUpload} className="hidden" />
                </label>
              )}
            </header>

            {/* Main Content */}
            <main className="flex-1 w-full flex flex-col bg-white rounded-xl shadow-xl overflow-hidden min-h-[600px] border border-slate-100 relative">
              
              {/* State: No Image */}
              {!originalImage && (
                <div className="flex-1 flex flex-col items-center justify-center p-8 bg-slate-50 border-2 border-dashed border-slate-300 m-4 rounded-xl hover:border-blue-400 hover:bg-slate-100 transition-all">
                  <div className="w-20 h-20 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center mb-6">
                      <UploadIcon />
                  </div>
                  <h2 className="text-xl font-semibold text-slate-700 mb-2">上传需要处理的图片</h2>
                  <p className="text-slate-500 mb-8 max-w-xs text-center">支持 JPG, PNG, WEBP 等常见格式。图片将上传至本地浏览器进行预览。</p>
                  <label className="bg-blue-600 text-white px-8 py-3 rounded-lg font-medium shadow-lg shadow-blue-600/30 hover:bg-blue-700 hover:shadow-blue-600/40 active:translate-y-0.5 transition-all cursor-pointer">
                      选择图片
                      <input type="file" accept="image/*" onChange={handleFileUpload} className="hidden" />
                  </label>
                </div>
              )}

              {/* State: Editing */}
              {originalImage && !processedImage && (
                <ImageEditor 
                  imageSrc={originalImage} 
                  onGenerate={handleGenerate}
                  isProcessing={isProcessing}
                />
              )}

              {/* State: Comparison */}
              {originalImage && processedImage && (
                <CompareView 
                  originalImage={originalImage} 
                  processedImage={processedImage}
                  onApply={handleApply}
                  onDownload={handleDownload}
                  onCancel={handleCancel}
                />
              )}

              {/* Loading Overlay */}
              {isProcessing && (
                <div className="absolute inset-0 bg-white/80 backdrop-blur-sm z-50 flex flex-col items-center justify-center animate-in fade-in duration-300">
                  <div className="bg-white p-8 rounded-2xl shadow-2xl flex flex-col items-center border border-slate-100">
                    <div className="text-blue-600 w-12 h-12 mb-4">
                        <LoaderIcon />
                    </div>
                    <h3 className="text-lg font-semibold text-slate-800">{loadingText}</h3>
                    <p className="text-slate-500 text-sm mt-2">AI 正在分析并重绘图像细节...</p>
                  </div>
                </div>
              )}

            </main>

            {/* Footer */}
            <footer className="w-full text-center py-6 text-slate-400 text-xs">
              &copy; 2024 自修室去水印 Powered by Gemini 2.5 Flash Image
            </footer>
          </div>
        );
      };

      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }

      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>